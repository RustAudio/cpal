//! Bindings generated by `minwin` 0.1.0
#![rustfmt::skip]
#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    clippy::upper_case_acronyms
)]
::windows_targets::link!(
    "kernel32.dll" "system" fn CloseHandle(hObject : HANDLE) -> BOOL
);
::windows_targets::link!(
    "kernel32.dll" "system" fn CreateEventA(lpEventAttributes : * const
    SECURITY_ATTRIBUTES, bManualReset : BOOL, bInitialState : BOOL, lpName :
    ::windows_core::PCSTR) -> HANDLE
);
::windows_targets::link!("kernel32.dll" "system" fn SetEvent(hEvent : HANDLE) -> BOOL);
::windows_targets::link!(
    "kernel32.dll" "system" fn WaitForMultipleObjectsEx(nCount : u32, lpHandles : * const
    HANDLE, bWaitAll : BOOL, dwMilliseconds : u32, bAlertable : BOOL) -> WIN32_ERROR
);
::windows_targets::link!(
    "ole32.dll" "system" fn CoCreateInstance(rclsid : * const ::windows_core::GUID,
    pUnkOuter : * mut ::core::ffi::c_void, dwClsContext : CLSCTX, riid : * const
    ::windows_core::GUID, ppv : * mut * mut ::core::ffi::c_void) ->
    ::windows_core::HRESULT
);
::windows_targets::link!(
    "ole32.dll" "system" fn CoInitializeEx(pvReserved : * const ::core::ffi::c_void,
    dwCoInit : COINIT) -> ::windows_core::HRESULT
);
::windows_targets::link!(
    "ole32.dll" "system" fn CoTaskMemFree(pv : * const ::core::ffi::c_void) -> ()
);
::windows_targets::link!("ole32.dll" "system" fn CoUninitialize() -> ());
::windows_targets::link!(
    "ole32.dll" "system" fn PropVariantClear(pvar : * mut PROPVARIANT) ->
    ::windows_core::HRESULT
);
pub const AUDCLNT_STREAMFLAGS_EVENTCALLBACK: u32 = 262144;
pub const AUDCLNT_STREAMFLAGS_LOOPBACK: u32 = 131072;
pub const DEVICE_STATE_ACTIVE: u32 = 1;
pub const DEVPKEY_Device_FriendlyName: DEVPROPKEY = DEVPROPKEY {
    fmtid: ::windows_core::GUID::from_u128(0xa45c254e_df1c_4efd_8020_67d146a850e0),
    pid: 14,
};
pub const INFINITE: u32 = 4294967295;
pub const KSAUDIO_SPEAKER_DIRECTOUT: u32 = 0;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const WAVE_FORMAT_EXTENSIBLE: u32 = 65534;
pub const WAVE_FORMAT_IEEE_FLOAT: u32 = 3;
pub const WAVE_FORMAT_PCM: u32 = 1;
pub const RPC_E_CHANGED_MODE: ::windows_core::HRESULT = ::windows_core::HRESULT(
    -2147417850,
);
pub const AUDCLNT_E_DEVICE_INVALIDATED: ::windows_core::HRESULT = ::windows_core::HRESULT(
    -2004287484,
);
pub const S_FALSE: ::windows_core::HRESULT = ::windows_core::HRESULT(1);
pub const AUDCLNT_S_BUFFER_EMPTY: ::windows_core::HRESULT = ::windows_core::HRESULT(
    143196161,
);
pub type ADVANCED_FEATURE_FLAGS = u16;
pub type AUDCLNT_SHAREMODE = i32;
pub const AUDCLNT_SHAREMODE_SHARED: AUDCLNT_SHAREMODE = 0;
#[repr(C)]
pub struct BLOB {
    pub cbSize: u32,
    pub pBlobData: *mut u8,
}
pub type BOOL = i32;
#[repr(C)]
pub struct BSTRBLOB {
    pub cbSize: u32,
    pub pData: *mut u8,
}
#[repr(C, packed(8))]
pub struct CABOOL {
    pub cElems: u32,
    pub pElems: *mut VARIANT_BOOL,
}
#[repr(C, packed(8))]
pub struct CABSTR {
    pub cElems: u32,
    pub pElems: *mut ::windows_core::BSTR,
}
#[repr(C, packed(8))]
pub struct CABSTRBLOB {
    pub cElems: u32,
    pub pElems: *mut BSTRBLOB,
}
#[repr(C, packed(8))]
pub struct CAC {
    pub cElems: u32,
    pub pElems: ::windows_core::PSTR,
}
#[repr(C, packed(8))]
pub struct CACLIPDATA {
    pub cElems: u32,
    pub pElems: *mut CLIPDATA,
}
#[repr(C, packed(8))]
pub struct CACLSID {
    pub cElems: u32,
    pub pElems: *mut ::windows_core::GUID,
}
#[repr(C, packed(8))]
pub struct CACY {
    pub cElems: u32,
    pub pElems: *mut CY,
}
#[repr(C, packed(8))]
pub struct CADATE {
    pub cElems: u32,
    pub pElems: *mut f64,
}
#[repr(C, packed(8))]
pub struct CADBL {
    pub cElems: u32,
    pub pElems: *mut f64,
}
#[repr(C, packed(8))]
pub struct CAFILETIME {
    pub cElems: u32,
    pub pElems: *mut FILETIME,
}
#[repr(C, packed(8))]
pub struct CAFLT {
    pub cElems: u32,
    pub pElems: *mut f32,
}
#[repr(C, packed(8))]
pub struct CAH {
    pub cElems: u32,
    pub pElems: *mut i64,
}
#[repr(C, packed(8))]
pub struct CAI {
    pub cElems: u32,
    pub pElems: *mut i16,
}
#[repr(C, packed(8))]
pub struct CAL {
    pub cElems: u32,
    pub pElems: *mut i32,
}
#[repr(C, packed(8))]
pub struct CALPSTR {
    pub cElems: u32,
    pub pElems: *mut ::windows_core::PSTR,
}
#[repr(C, packed(8))]
pub struct CALPWSTR {
    pub cElems: u32,
    pub pElems: *mut ::windows_core::PWSTR,
}
#[repr(C, packed(8))]
pub struct CAPROPVARIANT {
    pub cElems: u32,
    pub pElems: *mut PROPVARIANT,
}
#[repr(C, packed(8))]
pub struct CASCODE {
    pub cElems: u32,
    pub pElems: *mut i32,
}
#[repr(C, packed(8))]
pub struct CAUB {
    pub cElems: u32,
    pub pElems: *mut u8,
}
#[repr(C, packed(8))]
pub struct CAUH {
    pub cElems: u32,
    pub pElems: *mut u64,
}
#[repr(C, packed(8))]
pub struct CAUI {
    pub cElems: u32,
    pub pElems: *mut u16,
}
#[repr(C, packed(8))]
pub struct CAUL {
    pub cElems: u32,
    pub pElems: *mut u32,
}
#[repr(C)]
pub struct CLIPDATA {
    pub cbSize: u32,
    pub ulClipFmt: i32,
    pub pClipData: *mut u8,
}
pub type CLSCTX = u32;
pub const CLSCTX_ALL: CLSCTX = 23;
pub type COINIT = i32;
pub const COINIT_APARTMENTTHREADED: COINIT = 2;
#[repr(C)]
pub union CY {
    pub Anonymous: ::std::mem::ManuallyDrop<CY_0>,
    pub int64: i64,
}
#[repr(C)]
pub struct CY_0 {
    pub Lo: u32,
    pub Hi: i32,
}
#[repr(C)]
pub struct DECIMAL {
    pub wReserved: u16,
    pub Anonymous1: DECIMAL_0,
    pub Hi32: u32,
    pub Anonymous2: DECIMAL_1,
}
#[repr(C)]
pub union DECIMAL_0 {
    pub Anonymous: ::std::mem::ManuallyDrop<DECIMAL_0_0>,
    pub signscale: u16,
}
#[repr(C)]
pub struct DECIMAL_0_0 {
    pub scale: u8,
    pub sign: u8,
}
#[repr(C)]
pub union DECIMAL_1 {
    pub Anonymous: ::std::mem::ManuallyDrop<DECIMAL_1_0>,
    pub Lo64: u64,
}
#[repr(C)]
pub struct DECIMAL_1_0 {
    pub Lo32: u32,
    pub Mid32: u32,
}
#[repr(C)]
pub struct DEVPROPKEY {
    pub fmtid: ::windows_core::GUID,
    pub pid: u32,
}
pub type EDataFlow = i32;
pub const eRender: EDataFlow = 0;
pub const eCapture: EDataFlow = 1;
pub const eAll: EDataFlow = 2;
pub type ERole = i32;
pub const eConsole: ERole = 0;
#[repr(C)]
pub struct FILETIME {
    pub dwLowDateTime: u32,
    pub dwHighDateTime: u32,
}
pub type HANDLE = isize;
#[repr(C)]
pub struct IAudioCaptureClient_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub GetBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppData: *mut *mut u8,
        pNumFramesToRead: *mut u32,
        pdwFlags: *mut u32,
        pu64DevicePosition: *mut u64,
        pu64QPCPosition: *mut u64,
    ) -> ::windows_core::HRESULT,
    pub ReleaseBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        NumFramesRead: u32,
    ) -> ::windows_core::HRESULT,
    pub GetNextPacketSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pNumFramesInNextPacket: *mut u32,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
pub struct IAudioCaptureClient(::windows_core::IUnknown);
impl IAudioCaptureClient {
    pub unsafe fn GetBuffer(
        &self,
        ppData: *mut *mut u8,
        pNumFramesToRead: *mut u32,
        pdwFlags: *mut u32,
        pu64DevicePosition: ::core::option::Option<::core::ptr::NonNull<u64>>,
        pu64QPCPosition: ::core::option::Option<::core::ptr::NonNull<u64>>,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .GetBuffer)(
                ::windows_core::Interface::as_raw(self),
                ppData,
                pNumFramesToRead,
                pdwFlags,
                pu64DevicePosition
                    .map_or(::std::ptr::null_mut(), std::ptr::NonNull::as_ptr),
                pu64QPCPosition.map_or(::std::ptr::null_mut(), std::ptr::NonNull::as_ptr),
            )
            .ok()
    }
    pub unsafe fn ReleaseBuffer(
        &self,
        NumFramesRead: u32,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .ReleaseBuffer)(::windows_core::Interface::as_raw(self), NumFramesRead)
            .ok()
    }
    pub unsafe fn GetNextPacketSize(&self) -> ::windows_core::Result<u32> {
        let mut result__ = ::std::mem::MaybeUninit::<u32>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetNextPacketSize)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IAudioCaptureClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IAudioCaptureClient {
    type Vtable = IAudioCaptureClient_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IAudioCaptureClient {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0xc8adbd64_e71e_48a0_a4de_185c395cd317,
    );
}
#[repr(C)]
pub struct IAudioClient2_Vtbl {
    pub base__: IAudioClient_Vtbl,
    IsOffloadCapable: usize,
    SetClientProperties: usize,
    pub GetBufferSizeLimits: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pFormat: *const WAVEFORMATEX,
        bEventDriven: BOOL,
        phnsMinBufferDuration: *mut i64,
        phnsMaxBufferDuration: *mut i64,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
pub struct IAudioClient2(::windows_core::IUnknown);
impl IAudioClient2 {
    pub unsafe fn GetBufferSizeLimits(
        &self,
        pFormat: *const WAVEFORMATEX,
        bEventDriven: BOOL,
        phnsMinBufferDuration: *mut i64,
        phnsMaxBufferDuration: *mut i64,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .GetBufferSizeLimits)(
                ::windows_core::Interface::as_raw(self),
                pFormat,
                bEventDriven,
                phnsMinBufferDuration,
                phnsMaxBufferDuration,
            )
            .ok()
    }
}
impl ::core::clone::Clone for IAudioClient2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IAudioClient2 {
    type Vtable = IAudioClient2_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IAudioClient2 {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0x726778cd_f60a_4eda_82de_e47610cd78aa,
    );
}
#[repr(C)]
pub struct IAudioClient_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub Initialize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ShareMode: AUDCLNT_SHAREMODE,
        StreamFlags: u32,
        hnsBufferDuration: i64,
        hnsPeriodicity: i64,
        pFormat: *const WAVEFORMATEX,
        AudioSessionGuid: *const ::windows_core::GUID,
    ) -> ::windows_core::HRESULT,
    pub GetBufferSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pNumBufferFrames: *mut u32,
    ) -> ::windows_core::HRESULT,
    GetStreamLatency: usize,
    pub GetCurrentPadding: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pNumPaddingFrames: *mut u32,
    ) -> ::windows_core::HRESULT,
    pub IsFormatSupported: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ShareMode: AUDCLNT_SHAREMODE,
        pFormat: *const WAVEFORMATEX,
        ppClosestMatch: *mut *mut WAVEFORMATEX,
    ) -> ::windows_core::HRESULT,
    pub GetMixFormat: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppDeviceFormat: *mut *mut WAVEFORMATEX,
    ) -> ::windows_core::HRESULT,
    GetDevicePeriod: usize,
    pub Start: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub Stop: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    Reset: usize,
    pub SetEventHandle: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        eventHandle: HANDLE,
    ) -> ::windows_core::HRESULT,
    pub GetService: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows_core::GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
pub struct IAudioClient(::windows_core::IUnknown);
impl IAudioClient {
    pub unsafe fn Initialize(
        &self,
        ShareMode: AUDCLNT_SHAREMODE,
        StreamFlags: u32,
        hnsBufferDuration: i64,
        hnsPeriodicity: i64,
        pFormat: *const WAVEFORMATEX,
        AudioSessionGuid: ::core::option::Option<
            ::core::ptr::NonNull<::windows_core::GUID>,
        >,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .Initialize)(
                ::windows_core::Interface::as_raw(self),
                ShareMode,
                StreamFlags,
                hnsBufferDuration,
                hnsPeriodicity,
                pFormat,
                AudioSessionGuid.map_or(::std::ptr::null(), |p| p.as_ptr() as *const _),
            )
            .ok()
    }
    pub unsafe fn GetBufferSize(&self) -> ::windows_core::Result<u32> {
        let mut result__ = ::std::mem::MaybeUninit::<u32>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetBufferSize)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn GetCurrentPadding(&self) -> ::windows_core::Result<u32> {
        let mut result__ = ::std::mem::MaybeUninit::<u32>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetCurrentPadding)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn IsFormatSupported(
        &self,
        ShareMode: AUDCLNT_SHAREMODE,
        pFormat: *const WAVEFORMATEX,
        ppClosestMatch: ::core::option::Option<::core::ptr::NonNull<*mut WAVEFORMATEX>>,
    ) -> ::windows_core::HRESULT {
        (::windows_core::Interface::vtable(self)
            .IsFormatSupported)(
            ::windows_core::Interface::as_raw(self),
            ShareMode,
            pFormat,
            ppClosestMatch.map_or(::std::ptr::null_mut(), std::ptr::NonNull::as_ptr),
        )
    }
    pub unsafe fn GetMixFormat(&self) -> ::windows_core::Result<*mut WAVEFORMATEX> {
        let mut result__ = ::std::mem::MaybeUninit::<*mut WAVEFORMATEX>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetMixFormat)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn Start(&self) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .Start)(::windows_core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn Stop(&self) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .Stop)(::windows_core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn SetEventHandle(
        &self,
        eventHandle: HANDLE,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .SetEventHandle)(::windows_core::Interface::as_raw(self), eventHandle)
            .ok()
    }
    pub unsafe fn GetService<T>(&self) -> ::windows_core::Result<T>
    where
        T: ::windows_core::ComInterface,
    {
        let mut result__ = ::std::mem::MaybeUninit::uninit();
        wrap_interface_result(
            (::windows_core::Interface::vtable(self)
                .GetService)(
                ::windows_core::Interface::as_raw(self),
                &<T as ::windows_core::ComInterface>::IID,
                result__.as_mut_ptr(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IAudioClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IAudioClient {
    type Vtable = IAudioClient_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IAudioClient {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0x1cb9ad4c_dbfa_4c32_b178_c2f568a703b2,
    );
}
#[repr(C)]
pub struct IAudioClock_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    GetFrequency: usize,
    pub GetPosition: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pu64Position: *mut u64,
        pu64QPCPosition: *mut u64,
    ) -> ::windows_core::HRESULT,
    GetCharacteristics: usize,
}
#[repr(transparent)]
pub struct IAudioClock(::windows_core::IUnknown);
impl IAudioClock {
    pub unsafe fn GetPosition(
        &self,
        pu64Position: *mut u64,
        pu64QPCPosition: ::core::option::Option<::core::ptr::NonNull<u64>>,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .GetPosition)(
                ::windows_core::Interface::as_raw(self),
                pu64Position,
                pu64QPCPosition.map_or(::std::ptr::null_mut(), std::ptr::NonNull::as_ptr),
            )
            .ok()
    }
}
impl ::core::clone::Clone for IAudioClock {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IAudioClock {
    type Vtable = IAudioClock_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IAudioClock {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0xcd63314f_3fba_4a1b_812c_ef96358728e7,
    );
}
#[repr(C)]
pub struct IAudioRenderClient_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub GetBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        NumFramesRequested: u32,
        ppData: *mut *mut u8,
    ) -> ::windows_core::HRESULT,
    pub ReleaseBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        NumFramesWritten: u32,
        dwFlags: u32,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
pub struct IAudioRenderClient(::windows_core::IUnknown);
impl IAudioRenderClient {
    pub unsafe fn GetBuffer(
        &self,
        NumFramesRequested: u32,
    ) -> ::windows_core::Result<*mut u8> {
        let mut result__ = ::std::mem::MaybeUninit::<*mut u8>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetBuffer)(
                ::windows_core::Interface::as_raw(self),
                NumFramesRequested,
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn ReleaseBuffer(
        &self,
        NumFramesWritten: u32,
        dwFlags: u32,
    ) -> ::windows_core::Result<()> {
        (::windows_core::Interface::vtable(self)
            .ReleaseBuffer)(
                ::windows_core::Interface::as_raw(self),
                NumFramesWritten,
                dwFlags,
            )
            .ok()
    }
}
impl ::core::clone::Clone for IAudioRenderClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IAudioRenderClient {
    type Vtable = IAudioRenderClient_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IAudioRenderClient {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0xf294acfc_3146_4483_a7bf_addca7c260e2,
    );
}
#[repr(transparent)]
pub struct IDispatch(::windows_core::IUnknown);
#[repr(C)]
pub struct IMMDeviceCollection_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub GetCount: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pcDevices: *mut u32,
    ) -> ::windows_core::HRESULT,
    pub Item: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nDevice: u32,
        ppDevice: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
pub struct IMMDeviceCollection(::windows_core::IUnknown);
impl IMMDeviceCollection {
    pub unsafe fn GetCount(&self) -> ::windows_core::Result<u32> {
        let mut result__ = ::std::mem::MaybeUninit::<u32>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetCount)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn Item(&self, nDevice: u32) -> ::windows_core::Result<IMMDevice> {
        let mut result__ = ::std::mem::MaybeUninit::<IMMDevice>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .Item)(
                ::windows_core::Interface::as_raw(self),
                nDevice,
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IMMDeviceCollection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IMMDeviceCollection {
    type Vtable = IMMDeviceCollection_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IMMDeviceCollection {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0x0bd7a1be_7a1a_44db_8397_cc5392387b5e,
    );
}
#[repr(C)]
pub struct IMMDeviceEnumerator_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub EnumAudioEndpoints: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dataFlow: EDataFlow,
        dwStateMask: u32,
        ppDevices: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub GetDefaultAudioEndpoint: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dataFlow: EDataFlow,
        role: ERole,
        ppEndpoint: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    GetDevice: usize,
    RegisterEndpointNotificationCallback: usize,
    UnregisterEndpointNotificationCallback: usize,
}
#[repr(transparent)]
pub struct IMMDeviceEnumerator(::windows_core::IUnknown);
impl IMMDeviceEnumerator {
    pub unsafe fn EnumAudioEndpoints(
        &self,
        dataFlow: EDataFlow,
        dwStateMask: u32,
    ) -> ::windows_core::Result<IMMDeviceCollection> {
        let mut result__ = ::std::mem::MaybeUninit::<IMMDeviceCollection>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .EnumAudioEndpoints)(
                ::windows_core::Interface::as_raw(self),
                dataFlow,
                dwStateMask,
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn GetDefaultAudioEndpoint(
        &self,
        dataFlow: EDataFlow,
        role: ERole,
    ) -> ::windows_core::Result<IMMDevice> {
        let mut result__ = ::std::mem::MaybeUninit::<IMMDevice>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetDefaultAudioEndpoint)(
                ::windows_core::Interface::as_raw(self),
                dataFlow,
                role,
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IMMDeviceEnumerator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IMMDeviceEnumerator {
    type Vtable = IMMDeviceEnumerator_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IMMDeviceEnumerator {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0xa95664d2_9614_4f35_a746_de8db63617e6,
    );
}
#[repr(C)]
pub struct IMMDevice_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub Activate: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        iid: *const ::windows_core::GUID,
        dwClsCtx: CLSCTX,
        pActivationParams: *const PROPVARIANT,
        ppInterface: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub OpenPropertyStore: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        stgmAccess: STGM,
        ppProperties: *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub GetId: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppstrId: *mut ::windows_core::PWSTR,
    ) -> ::windows_core::HRESULT,
    GetState: usize,
}
#[repr(transparent)]
pub struct IMMDevice(::windows_core::IUnknown);
impl IMMDevice {
    pub unsafe fn Activate<T>(
        &self,
        dwClsCtx: CLSCTX,
        pActivationParams: ::core::option::Option<::core::ptr::NonNull<PROPVARIANT>>,
    ) -> ::windows_core::Result<T>
    where
        T: ::windows_core::ComInterface,
    {
        let mut result__ = ::std::mem::MaybeUninit::uninit();
        wrap_interface_result(
            (::windows_core::Interface::vtable(self)
                .Activate)(
                ::windows_core::Interface::as_raw(self),
                &<T as ::windows_core::ComInterface>::IID,
                dwClsCtx,
                pActivationParams.map_or(::std::ptr::null(), |p| p.as_ptr() as *const _),
                result__.as_mut_ptr(),
            ),
            result__,
        )
    }
    pub unsafe fn OpenPropertyStore(
        &self,
        stgmAccess: STGM,
    ) -> ::windows_core::Result<IPropertyStore> {
        let mut result__ = ::std::mem::MaybeUninit::<IPropertyStore>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .OpenPropertyStore)(
                ::windows_core::Interface::as_raw(self),
                stgmAccess,
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
    pub unsafe fn GetId(&self) -> ::windows_core::Result<::windows_core::PWSTR> {
        let mut result__ = ::std::mem::MaybeUninit::<::windows_core::PWSTR>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetId)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IMMDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IMMDevice {
    type Vtable = IMMDevice_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IMMDevice {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0xd666063f_1587_4e43_81f1_b948e807363f,
    );
}
#[repr(C)]
pub struct IMMEndpoint_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    pub GetDataFlow: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pDataFlow: *mut EDataFlow,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
pub struct IMMEndpoint(::windows_core::IUnknown);
impl IMMEndpoint {
    pub unsafe fn GetDataFlow(&self) -> ::windows_core::Result<EDataFlow> {
        let mut result__ = ::std::mem::MaybeUninit::<EDataFlow>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetDataFlow)(
                ::windows_core::Interface::as_raw(self),
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IMMEndpoint {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IMMEndpoint {
    type Vtable = IMMEndpoint_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IMMEndpoint {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0x1be09788_6894_4089_8586_9a2a6c265ac5,
    );
}
#[repr(C)]
pub struct IPropertyStore_Vtbl {
    pub base__: ::windows_core::IUnknown_Vtbl,
    GetCount: usize,
    GetAt: usize,
    pub GetValue: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        key: *const PROPERTYKEY,
        pv: *mut PROPVARIANT,
    ) -> ::windows_core::HRESULT,
    SetValue: usize,
    Commit: usize,
}
#[repr(transparent)]
pub struct IPropertyStore(::windows_core::IUnknown);
impl IPropertyStore {
    pub unsafe fn GetValue(
        &self,
        key: *const PROPERTYKEY,
    ) -> ::windows_core::Result<PROPVARIANT> {
        let mut result__ = ::std::mem::MaybeUninit::<PROPVARIANT>::uninit();
        wrap_value_result(
            (::windows_core::Interface::vtable(self)
                .GetValue)(
                ::windows_core::Interface::as_raw(self),
                key,
                result__.as_mut_ptr().cast(),
            ),
            result__,
        )
    }
}
impl ::core::clone::Clone for IPropertyStore {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows_core::Interface for IPropertyStore {
    type Vtable = IPropertyStore_Vtbl;
}
unsafe impl ::windows_core::ComInterface for IPropertyStore {
    const IID: ::windows_core::GUID = ::windows_core::GUID::from_u128(
        0x886d8eeb_8cf2_4446_8d02_cdba1dbdcf99,
    );
}
#[repr(transparent)]
pub struct IStorage(::windows_core::IUnknown);
#[repr(transparent)]
pub struct IStream(::windows_core::IUnknown);
pub const KSDATAFORMAT_SUBTYPE_IEEE_FLOAT: ::windows_core::GUID = ::windows_core::GUID::from_u128(
    0x00000003_0000_0010_8000_00aa00389b71,
);
pub const KSDATAFORMAT_SUBTYPE_PCM: ::windows_core::GUID = ::windows_core::GUID::from_u128(
    0x00000001_0000_0010_8000_00aa00389b71,
);
pub const MMDeviceEnumerator: ::windows_core::GUID = ::windows_core::GUID::from_u128(
    0xbcde0395_e52f_467c_8e3d_c4579291692e,
);
#[repr(C)]
pub struct PROPERTYKEY {
    pub fmtid: ::windows_core::GUID,
    pub pid: u32,
}
#[repr(C)]
pub struct PROPVARIANT {
    pub Anonymous: PROPVARIANT_0,
}
#[repr(C)]
pub union PROPVARIANT_0 {
    pub Anonymous: ::std::mem::ManuallyDrop<PROPVARIANT_0_0>,
    pub decVal: ::std::mem::ManuallyDrop<DECIMAL>,
}
#[repr(C)]
pub struct PROPVARIANT_0_0 {
    pub vt: VARENUM,
    pub wReserved1: u16,
    pub wReserved2: u16,
    pub wReserved3: u16,
    pub Anonymous: PROPVARIANT_0_0_0,
}
#[repr(C)]
pub union PROPVARIANT_0_0_0 {
    pub cVal: u8,
    pub bVal: u8,
    pub iVal: i16,
    pub uiVal: u16,
    pub lVal: i32,
    pub ulVal: u32,
    pub intVal: i32,
    pub uintVal: u32,
    pub hVal: i64,
    pub uhVal: u64,
    pub fltVal: f32,
    pub dblVal: f64,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: i32,
    pub cyVal: ::std::mem::ManuallyDrop<CY>,
    pub date: f64,
    pub filetime: ::std::mem::ManuallyDrop<FILETIME>,
    pub puuid: *mut ::windows_core::GUID,
    pub pclipdata: *mut CLIPDATA,
    pub bstrVal: ::std::mem::ManuallyDrop<::windows_core::BSTR>,
    pub bstrblobVal: ::std::mem::ManuallyDrop<BSTRBLOB>,
    pub blob: ::std::mem::ManuallyDrop<BLOB>,
    pub pszVal: ::windows_core::PSTR,
    pub pwszVal: ::windows_core::PWSTR,
    pub punkVal: ::std::mem::ManuallyDrop<::windows_core::IUnknown>,
    pub pdispVal: ::std::mem::ManuallyDrop<IDispatch>,
    pub pStream: ::std::mem::ManuallyDrop<IStream>,
    pub pStorage: ::std::mem::ManuallyDrop<IStorage>,
    pub pVersionedStream: *mut VERSIONEDSTREAM,
    pub parray: *mut SAFEARRAY,
    pub cac: ::std::mem::ManuallyDrop<CAC>,
    pub caub: ::std::mem::ManuallyDrop<CAUB>,
    pub cai: ::std::mem::ManuallyDrop<CAI>,
    pub caui: ::std::mem::ManuallyDrop<CAUI>,
    pub cal: ::std::mem::ManuallyDrop<CAL>,
    pub caul: ::std::mem::ManuallyDrop<CAUL>,
    pub cah: ::std::mem::ManuallyDrop<CAH>,
    pub cauh: ::std::mem::ManuallyDrop<CAUH>,
    pub caflt: ::std::mem::ManuallyDrop<CAFLT>,
    pub cadbl: ::std::mem::ManuallyDrop<CADBL>,
    pub cabool: ::std::mem::ManuallyDrop<CABOOL>,
    pub cascode: ::std::mem::ManuallyDrop<CASCODE>,
    pub cacy: ::std::mem::ManuallyDrop<CACY>,
    pub cadate: ::std::mem::ManuallyDrop<CADATE>,
    pub cafiletime: ::std::mem::ManuallyDrop<CAFILETIME>,
    pub cauuid: ::std::mem::ManuallyDrop<CACLSID>,
    pub caclipdata: ::std::mem::ManuallyDrop<CACLIPDATA>,
    pub cabstr: ::std::mem::ManuallyDrop<CABSTR>,
    pub cabstrblob: ::std::mem::ManuallyDrop<CABSTRBLOB>,
    pub calpstr: ::std::mem::ManuallyDrop<CALPSTR>,
    pub calpwstr: ::std::mem::ManuallyDrop<CALPWSTR>,
    pub capropvar: ::std::mem::ManuallyDrop<CAPROPVARIANT>,
    pub pcVal: ::windows_core::PSTR,
    pub pbVal: *mut u8,
    pub piVal: *mut i16,
    pub puiVal: *mut u16,
    pub plVal: *mut i32,
    pub pulVal: *mut u32,
    pub pintVal: *mut i32,
    pub puintVal: *mut u32,
    pub pfltVal: *mut f32,
    pub pdblVal: *mut f64,
    pub pboolVal: *mut VARIANT_BOOL,
    pub pdecVal: *mut DECIMAL,
    pub pscode: *mut i32,
    pub pcyVal: *mut CY,
    pub pdate: *mut f64,
    pub pbstrVal: *mut ::windows_core::BSTR,
    pub ppunkVal: *mut ::windows_core::IUnknown,
    pub ppdispVal: *mut IDispatch,
    pub pparray: *mut *mut SAFEARRAY,
    pub pvarVal: *mut PROPVARIANT,
}
#[repr(C, packed(8))]
pub struct SAFEARRAY {
    pub cDims: u16,
    pub fFeatures: ADVANCED_FEATURE_FLAGS,
    pub cbElements: u32,
    pub cLocks: u32,
    pub pvData: *mut ::core::ffi::c_void,
    pub rgsabound: [SAFEARRAYBOUND; 1],
}
#[repr(C, packed(8))]
pub struct SAFEARRAYBOUND {
    pub cElements: u32,
    pub lLbound: i32,
}
#[repr(C)]
pub struct SECURITY_ATTRIBUTES {
    pub nLength: u32,
    pub lpSecurityDescriptor: *mut ::core::ffi::c_void,
    pub bInheritHandle: BOOL,
}
pub type STGM = u32;
pub const STGM_READ: STGM = 0;
pub type VARENUM = u16;
pub const VT_LPWSTR: VARENUM = 31;
pub type VARIANT_BOOL = i16;
#[repr(C, packed(8))]
pub struct VERSIONEDSTREAM {
    pub guidVersion: ::windows_core::GUID,
    pub pStream: IStream,
}
#[repr(C, packed(1))]
pub struct WAVEFORMATEX {
    pub wFormatTag: u16,
    pub nChannels: u16,
    pub nSamplesPerSec: u32,
    pub nAvgBytesPerSec: u32,
    pub nBlockAlign: u16,
    pub wBitsPerSample: u16,
    pub cbSize: u16,
}
#[repr(C, packed(1))]
pub struct WAVEFORMATEXTENSIBLE {
    pub Format: WAVEFORMATEX,
    pub Samples: WAVEFORMATEXTENSIBLE_0,
    pub dwChannelMask: u32,
    pub SubFormat: ::windows_core::GUID,
}
#[repr(C, packed(1))]
pub union WAVEFORMATEXTENSIBLE_0 {
    pub wValidBitsPerSample: u16,
    pub wSamplesPerBlock: u16,
    pub wReserved: u16,
}
pub type WIN32_ERROR = u32;
pub const WAIT_OBJECT_0: WIN32_ERROR = 0;
pub const WAIT_FAILED: WIN32_ERROR = 4294967295;
#[inline]
unsafe fn wrap_interface_result<T>(
    hresult: ::windows_core::HRESULT,
    res: ::std::mem::MaybeUninit<*mut ::std::ffi::c_void>,
) -> ::windows_core::Result<T> {
    if hresult.is_ok() {
        Ok(std::mem::transmute_copy(&res.assume_init()))
    } else {
        Err(::windows_core::Error::from(hresult))
    }
}
#[inline]
unsafe fn wrap_value_result<T>(
    hresult: ::windows_core::HRESULT,
    res: ::std::mem::MaybeUninit<T>,
) -> ::windows_core::Result<T> {
    if hresult.is_ok() {
        Ok(res.assume_init())
    } else {
        Err(::windows_core::Error::from(hresult))
    }
}
