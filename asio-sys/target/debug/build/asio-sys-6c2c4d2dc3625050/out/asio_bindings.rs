/* automatically generated by rust-bindgen */

pub const MAC: u32 = 1;
pub const PPC: u32 = 1;
pub const WINDOWS: u32 = 0;
pub const PC: u32 = 0;
pub const SGI: u32 = 0;
pub const SUN: u32 = 0;
pub const LINUX: u32 = 0;
pub const BEOS: u32 = 0;
pub const NATIVE_INT64: u32 = 0;
pub const IEEE754_64FLOAT: u32 = 1;
pub const DEBUG: u32 = 0;
pub const ASIO_BIG_ENDIAN: u32 = 1;
pub const ASIO_CPU_PPC: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOSamples {
    pub hi: ::std::os::raw::c_ulong,
    pub lo: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ASIOSamples() {
    assert_eq!(
        ::std::mem::size_of::<ASIOSamples>(),
        16usize,
        concat!("Size of: ", stringify!(ASIOSamples))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOSamples>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOSamples))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOSamples>())).hi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOSamples),
            "::",
            stringify!(hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOSamples>())).lo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOSamples),
            "::",
            stringify!(lo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOTimeStamp {
    pub hi: ::std::os::raw::c_ulong,
    pub lo: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ASIOTimeStamp() {
    assert_eq!(
        ::std::mem::size_of::<ASIOTimeStamp>(),
        16usize,
        concat!("Size of: ", stringify!(ASIOTimeStamp))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOTimeStamp>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOTimeStamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTimeStamp>())).hi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTimeStamp),
            "::",
            stringify!(hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTimeStamp>())).lo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTimeStamp),
            "::",
            stringify!(lo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOSampleRate {
    pub ieee: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_ASIOSampleRate() {
    assert_eq!(
        ::std::mem::size_of::<ASIOSampleRate>(),
        8usize,
        concat!("Size of: ", stringify!(ASIOSampleRate))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOSampleRate>(),
        1usize,
        concat!("Alignment of ", stringify!(ASIOSampleRate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOSampleRate>())).ieee as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOSampleRate),
            "::",
            stringify!(ieee)
        )
    );
}
pub type ASIOBool = ::std::os::raw::c_long;
pub const ASIOFalse: _bindgen_ty_1 = 0;
pub const ASIOTrue: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = u32;
pub type ASIOSampleType = ::std::os::raw::c_long;
pub const ASIOSTInt16MSB: _bindgen_ty_2 = 0;
pub const ASIOSTInt24MSB: _bindgen_ty_2 = 1;
pub const ASIOSTInt32MSB: _bindgen_ty_2 = 2;
pub const ASIOSTFloat32MSB: _bindgen_ty_2 = 3;
pub const ASIOSTFloat64MSB: _bindgen_ty_2 = 4;
pub const ASIOSTInt32MSB16: _bindgen_ty_2 = 8;
pub const ASIOSTInt32MSB18: _bindgen_ty_2 = 9;
pub const ASIOSTInt32MSB20: _bindgen_ty_2 = 10;
pub const ASIOSTInt32MSB24: _bindgen_ty_2 = 11;
pub const ASIOSTInt16LSB: _bindgen_ty_2 = 16;
pub const ASIOSTInt24LSB: _bindgen_ty_2 = 17;
pub const ASIOSTInt32LSB: _bindgen_ty_2 = 18;
pub const ASIOSTFloat32LSB: _bindgen_ty_2 = 19;
pub const ASIOSTFloat64LSB: _bindgen_ty_2 = 20;
pub const ASIOSTInt32LSB16: _bindgen_ty_2 = 24;
pub const ASIOSTInt32LSB18: _bindgen_ty_2 = 25;
pub const ASIOSTInt32LSB20: _bindgen_ty_2 = 26;
pub const ASIOSTInt32LSB24: _bindgen_ty_2 = 27;
pub const ASIOSTDSDInt8LSB1: _bindgen_ty_2 = 32;
pub const ASIOSTDSDInt8MSB1: _bindgen_ty_2 = 33;
pub const ASIOSTDSDInt8NER8: _bindgen_ty_2 = 40;
pub const ASIOSTLastEntry: _bindgen_ty_2 = 41;
pub type _bindgen_ty_2 = u32;
pub type ASIOError = ::std::os::raw::c_long;
pub const ASE_OK: _bindgen_ty_3 = 0;
pub const ASE_SUCCESS: _bindgen_ty_3 = 1061701536;
pub const ASE_NotPresent: _bindgen_ty_3 = -1000;
pub const ASE_HWMalfunction: _bindgen_ty_3 = -999;
pub const ASE_InvalidParameter: _bindgen_ty_3 = -998;
pub const ASE_InvalidMode: _bindgen_ty_3 = -997;
pub const ASE_SPNotAdvancing: _bindgen_ty_3 = -996;
pub const ASE_NoClock: _bindgen_ty_3 = -995;
pub const ASE_NoMemory: _bindgen_ty_3 = -994;
pub type _bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIOTimeCode {
    pub speed: f64,
    pub timeCodeSamples: ASIOSamples,
    pub flags: ::std::os::raw::c_ulong,
    pub future: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_ASIOTimeCode() {
    assert_eq!(
        ::std::mem::size_of::<ASIOTimeCode>(),
        96usize,
        concat!("Size of: ", stringify!(ASIOTimeCode))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOTimeCode>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOTimeCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTimeCode>())).speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTimeCode),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTimeCode>())).timeCodeSamples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTimeCode),
            "::",
            stringify!(timeCodeSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTimeCode>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTimeCode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTimeCode>())).future as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTimeCode),
            "::",
            stringify!(future)
        )
    );
}
pub const ASIOTimeCodeFlags_kTcValid: ASIOTimeCodeFlags = 1;
pub const ASIOTimeCodeFlags_kTcRunning: ASIOTimeCodeFlags = 2;
pub const ASIOTimeCodeFlags_kTcReverse: ASIOTimeCodeFlags = 4;
pub const ASIOTimeCodeFlags_kTcOnspeed: ASIOTimeCodeFlags = 8;
pub const ASIOTimeCodeFlags_kTcStill: ASIOTimeCodeFlags = 16;
pub const ASIOTimeCodeFlags_kTcSpeedValid: ASIOTimeCodeFlags = 256;
pub type ASIOTimeCodeFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsioTimeInfo {
    pub speed: f64,
    pub systemTime: ASIOTimeStamp,
    pub samplePosition: ASIOSamples,
    pub sampleRate: ASIOSampleRate,
    pub flags: ::std::os::raw::c_ulong,
    pub reserved: [::std::os::raw::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_AsioTimeInfo() {
    assert_eq!(
        ::std::mem::size_of::<AsioTimeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(AsioTimeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AsioTimeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AsioTimeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioTimeInfo>())).speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioTimeInfo),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioTimeInfo>())).systemTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioTimeInfo),
            "::",
            stringify!(systemTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioTimeInfo>())).samplePosition as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioTimeInfo),
            "::",
            stringify!(samplePosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioTimeInfo>())).sampleRate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioTimeInfo),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioTimeInfo>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioTimeInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioTimeInfo>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioTimeInfo),
            "::",
            stringify!(reserved)
        )
    );
}
pub const AsioTimeInfoFlags_kSystemTimeValid: AsioTimeInfoFlags = 1;
pub const AsioTimeInfoFlags_kSamplePositionValid: AsioTimeInfoFlags = 2;
pub const AsioTimeInfoFlags_kSampleRateValid: AsioTimeInfoFlags = 4;
pub const AsioTimeInfoFlags_kSpeedValid: AsioTimeInfoFlags = 8;
pub const AsioTimeInfoFlags_kSampleRateChanged: AsioTimeInfoFlags = 16;
pub const AsioTimeInfoFlags_kClockSourceChanged: AsioTimeInfoFlags = 32;
pub type AsioTimeInfoFlags = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIOTime {
    pub reserved: [::std::os::raw::c_long; 4usize],
    pub timeInfo: AsioTimeInfo,
    pub timeCode: ASIOTimeCode,
}
#[test]
fn bindgen_test_layout_ASIOTime() {
    assert_eq!(
        ::std::mem::size_of::<ASIOTime>(),
        200usize,
        concat!("Size of: ", stringify!(ASIOTime))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOTime>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOTime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTime>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTime),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTime>())).timeInfo as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTime),
            "::",
            stringify!(timeInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTime>())).timeCode as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTime),
            "::",
            stringify!(timeCode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOCallbacks {
    pub bufferSwitch: ::std::option::Option<
        unsafe extern "C" fn(doubleBufferIndex: ::std::os::raw::c_long, directProcess: ASIOBool),
    >,
    pub sampleRateDidChange: ::std::option::Option<unsafe extern "C" fn(sRate: ASIOSampleRate)>,
    pub asioMessage: ::std::option::Option<
        unsafe extern "C" fn(
            selector: ::std::os::raw::c_long,
            value: ::std::os::raw::c_long,
            message: *mut ::std::os::raw::c_void,
            opt: *mut f64,
        ) -> ::std::os::raw::c_long,
    >,
    pub bufferSwitchTimeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            params: *mut ASIOTime,
            doubleBufferIndex: ::std::os::raw::c_long,
            directProcess: ASIOBool,
        ) -> *mut ASIOTime,
    >,
}
#[test]
fn bindgen_test_layout_ASIOCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<ASIOCallbacks>(),
        32usize,
        concat!("Size of: ", stringify!(ASIOCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOCallbacks>())).bufferSwitch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOCallbacks),
            "::",
            stringify!(bufferSwitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOCallbacks>())).sampleRateDidChange as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOCallbacks),
            "::",
            stringify!(sampleRateDidChange)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOCallbacks>())).asioMessage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOCallbacks),
            "::",
            stringify!(asioMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOCallbacks>())).bufferSwitchTimeInfo as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOCallbacks),
            "::",
            stringify!(bufferSwitchTimeInfo)
        )
    );
}
pub const kAsioSelectorSupported: _bindgen_ty_4 = 1;
pub const kAsioEngineVersion: _bindgen_ty_4 = 2;
pub const kAsioResetRequest: _bindgen_ty_4 = 3;
pub const kAsioBufferSizeChange: _bindgen_ty_4 = 4;
pub const kAsioResyncRequest: _bindgen_ty_4 = 5;
pub const kAsioLatenciesChanged: _bindgen_ty_4 = 6;
pub const kAsioSupportsTimeInfo: _bindgen_ty_4 = 7;
pub const kAsioSupportsTimeCode: _bindgen_ty_4 = 8;
pub const kAsioMMCCommand: _bindgen_ty_4 = 9;
pub const kAsioSupportsInputMonitor: _bindgen_ty_4 = 10;
pub const kAsioSupportsInputGain: _bindgen_ty_4 = 11;
pub const kAsioSupportsInputMeter: _bindgen_ty_4 = 12;
pub const kAsioSupportsOutputGain: _bindgen_ty_4 = 13;
pub const kAsioSupportsOutputMeter: _bindgen_ty_4 = 14;
pub const kAsioOverload: _bindgen_ty_4 = 15;
pub const kAsioNumMessageSelectors: _bindgen_ty_4 = 16;
pub type _bindgen_ty_4 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIODriverInfo {
    pub asioVersion: ::std::os::raw::c_long,
    pub driverVersion: ::std::os::raw::c_long,
    pub name: [::std::os::raw::c_char; 32usize],
    pub errorMessage: [::std::os::raw::c_char; 124usize],
    pub sysRef: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ASIODriverInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASIODriverInfo>(),
        184usize,
        concat!("Size of: ", stringify!(ASIODriverInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIODriverInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIODriverInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIODriverInfo>())).asioVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIODriverInfo),
            "::",
            stringify!(asioVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIODriverInfo>())).driverVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIODriverInfo),
            "::",
            stringify!(driverVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIODriverInfo>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIODriverInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIODriverInfo>())).errorMessage as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIODriverInfo),
            "::",
            stringify!(errorMessage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIODriverInfo>())).sysRef as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIODriverInfo),
            "::",
            stringify!(sysRef)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z8ASIOInitP14ASIODriverInfo"]
    pub fn ASIOInit(info: *mut ASIODriverInfo) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z8ASIOExitv"]
    pub fn ASIOExit() -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z9ASIOStartv"]
    pub fn ASIOStart() -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z8ASIOStopv"]
    pub fn ASIOStop() -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z15ASIOGetChannelsPlS_"]
    pub fn ASIOGetChannels(
        numInputChannels: *mut ::std::os::raw::c_long,
        numOutputChannels: *mut ::std::os::raw::c_long,
    ) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z16ASIOGetLatenciesPlS_"]
    pub fn ASIOGetLatencies(
        inputLatency: *mut ::std::os::raw::c_long,
        outputLatency: *mut ::std::os::raw::c_long,
    ) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z17ASIOGetBufferSizePlS_S_S_"]
    pub fn ASIOGetBufferSize(
        minSize: *mut ::std::os::raw::c_long,
        maxSize: *mut ::std::os::raw::c_long,
        preferredSize: *mut ::std::os::raw::c_long,
        granularity: *mut ::std::os::raw::c_long,
    ) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z17ASIOCanSampleRate14ASIOSampleRate"]
    pub fn ASIOCanSampleRate(sampleRate: ASIOSampleRate) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z17ASIOGetSampleRateP14ASIOSampleRate"]
    pub fn ASIOGetSampleRate(currentRate: *mut ASIOSampleRate) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z17ASIOSetSampleRate14ASIOSampleRate"]
    pub fn ASIOSetSampleRate(sampleRate: ASIOSampleRate) -> ASIOError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOClockSource {
    pub index: ::std::os::raw::c_long,
    pub associatedChannel: ::std::os::raw::c_long,
    pub associatedGroup: ::std::os::raw::c_long,
    pub isCurrentSource: ASIOBool,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_ASIOClockSource() {
    assert_eq!(
        ::std::mem::size_of::<ASIOClockSource>(),
        64usize,
        concat!("Size of: ", stringify!(ASIOClockSource))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOClockSource>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOClockSource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOClockSource>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOClockSource),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOClockSource>())).associatedChannel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOClockSource),
            "::",
            stringify!(associatedChannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOClockSource>())).associatedGroup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOClockSource),
            "::",
            stringify!(associatedGroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOClockSource>())).isCurrentSource as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOClockSource),
            "::",
            stringify!(isCurrentSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOClockSource>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOClockSource),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z19ASIOGetClockSourcesP15ASIOClockSourcePl"]
    pub fn ASIOGetClockSources(
        clocks: *mut ASIOClockSource,
        numSources: *mut ::std::os::raw::c_long,
    ) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z18ASIOSetClockSourcel"]
    pub fn ASIOSetClockSource(index: ::std::os::raw::c_long) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z21ASIOGetSamplePositionP11ASIOSamplesP13ASIOTimeStamp"]
    pub fn ASIOGetSamplePosition(sPos: *mut ASIOSamples, tStamp: *mut ASIOTimeStamp) -> ASIOError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOChannelInfo {
    pub channel: ::std::os::raw::c_long,
    pub isInput: ASIOBool,
    pub isActive: ASIOBool,
    pub channelGroup: ::std::os::raw::c_long,
    pub type_: ASIOSampleType,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_ASIOChannelInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASIOChannelInfo>(),
        72usize,
        concat!("Size of: ", stringify!(ASIOChannelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOChannelInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOChannelInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelInfo>())).channel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelInfo),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelInfo>())).isInput as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelInfo),
            "::",
            stringify!(isInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelInfo>())).isActive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelInfo),
            "::",
            stringify!(isActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelInfo>())).channelGroup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelInfo),
            "::",
            stringify!(channelGroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelInfo>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelInfo>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelInfo),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z18ASIOGetChannelInfoP15ASIOChannelInfo"]
    pub fn ASIOGetChannelInfo(info: *mut ASIOChannelInfo) -> ASIOError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOBufferInfo {
    pub isInput: ASIOBool,
    pub channelNum: ::std::os::raw::c_long,
    pub buffers: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_ASIOBufferInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASIOBufferInfo>(),
        32usize,
        concat!("Size of: ", stringify!(ASIOBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOBufferInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOBufferInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOBufferInfo>())).isInput as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOBufferInfo),
            "::",
            stringify!(isInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOBufferInfo>())).channelNum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOBufferInfo),
            "::",
            stringify!(channelNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOBufferInfo>())).buffers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOBufferInfo),
            "::",
            stringify!(buffers)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z17ASIOCreateBuffersP14ASIOBufferInfollP13ASIOCallbacks"]
    pub fn ASIOCreateBuffers(
        bufferInfos: *mut ASIOBufferInfo,
        numChannels: ::std::os::raw::c_long,
        bufferSize: ::std::os::raw::c_long,
        callbacks: *mut ASIOCallbacks,
    ) -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z18ASIODisposeBuffersv"]
    pub fn ASIODisposeBuffers() -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z16ASIOControlPanelv"]
    pub fn ASIOControlPanel() -> ASIOError;
}
extern "C" {
    #[link_name = "\u{1}__Z10ASIOFuturelPv"]
    pub fn ASIOFuture(
        selector: ::std::os::raw::c_long,
        params: *mut ::std::os::raw::c_void,
    ) -> ASIOError;
}
pub const kAsioEnableTimeCodeRead: _bindgen_ty_5 = 1;
pub const kAsioDisableTimeCodeRead: _bindgen_ty_5 = 2;
pub const kAsioSetInputMonitor: _bindgen_ty_5 = 3;
pub const kAsioTransport: _bindgen_ty_5 = 4;
pub const kAsioSetInputGain: _bindgen_ty_5 = 5;
pub const kAsioGetInputMeter: _bindgen_ty_5 = 6;
pub const kAsioSetOutputGain: _bindgen_ty_5 = 7;
pub const kAsioGetOutputMeter: _bindgen_ty_5 = 8;
pub const kAsioCanInputMonitor: _bindgen_ty_5 = 9;
pub const kAsioCanTimeInfo: _bindgen_ty_5 = 10;
pub const kAsioCanTimeCode: _bindgen_ty_5 = 11;
pub const kAsioCanTransport: _bindgen_ty_5 = 12;
pub const kAsioCanInputGain: _bindgen_ty_5 = 13;
pub const kAsioCanInputMeter: _bindgen_ty_5 = 14;
pub const kAsioCanOutputGain: _bindgen_ty_5 = 15;
pub const kAsioCanOutputMeter: _bindgen_ty_5 = 16;
pub const kAsioOptionalOne: _bindgen_ty_5 = 17;
pub const kAsioSetIoFormat: _bindgen_ty_5 = 588323169;
pub const kAsioGetIoFormat: _bindgen_ty_5 = 588323203;
pub const kAsioCanDoIoFormat: _bindgen_ty_5 = 588324868;
pub const kAsioCanReportOverload: _bindgen_ty_5 = 604250130;
pub const kAsioGetInternalBufferSamples: _bindgen_ty_5 = 621027346;
pub type _bindgen_ty_5 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOInputMonitor {
    pub input: ::std::os::raw::c_long,
    pub output: ::std::os::raw::c_long,
    pub gain: ::std::os::raw::c_long,
    pub state: ASIOBool,
    pub pan: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ASIOInputMonitor() {
    assert_eq!(
        ::std::mem::size_of::<ASIOInputMonitor>(),
        40usize,
        concat!("Size of: ", stringify!(ASIOInputMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOInputMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOInputMonitor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOInputMonitor>())).input as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInputMonitor),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOInputMonitor>())).output as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInputMonitor),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOInputMonitor>())).gain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInputMonitor),
            "::",
            stringify!(gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOInputMonitor>())).state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInputMonitor),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOInputMonitor>())).pan as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInputMonitor),
            "::",
            stringify!(pan)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOChannelControls {
    pub channel: ::std::os::raw::c_long,
    pub isInput: ASIOBool,
    pub gain: ::std::os::raw::c_long,
    pub meter: ::std::os::raw::c_long,
    pub future: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_ASIOChannelControls() {
    assert_eq!(
        ::std::mem::size_of::<ASIOChannelControls>(),
        64usize,
        concat!("Size of: ", stringify!(ASIOChannelControls))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOChannelControls>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOChannelControls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelControls>())).channel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelControls),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelControls>())).isInput as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelControls),
            "::",
            stringify!(isInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelControls>())).gain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelControls),
            "::",
            stringify!(gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelControls>())).meter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelControls),
            "::",
            stringify!(meter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOChannelControls>())).future as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOChannelControls),
            "::",
            stringify!(future)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIOTransportParameters {
    pub command: ::std::os::raw::c_long,
    pub samplePosition: ASIOSamples,
    pub track: ::std::os::raw::c_long,
    pub trackSwitches: [::std::os::raw::c_long; 16usize],
    pub future: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_ASIOTransportParameters() {
    assert_eq!(
        ::std::mem::size_of::<ASIOTransportParameters>(),
        224usize,
        concat!("Size of: ", stringify!(ASIOTransportParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOTransportParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOTransportParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTransportParameters>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTransportParameters),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOTransportParameters>())).samplePosition as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTransportParameters),
            "::",
            stringify!(samplePosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTransportParameters>())).track as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTransportParameters),
            "::",
            stringify!(track)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOTransportParameters>())).trackSwitches as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTransportParameters),
            "::",
            stringify!(trackSwitches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOTransportParameters>())).future as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOTransportParameters),
            "::",
            stringify!(future)
        )
    );
}
pub const kTransStart: _bindgen_ty_6 = 1;
pub const kTransStop: _bindgen_ty_6 = 2;
pub const kTransLocate: _bindgen_ty_6 = 3;
pub const kTransPunchIn: _bindgen_ty_6 = 4;
pub const kTransPunchOut: _bindgen_ty_6 = 5;
pub const kTransArmOn: _bindgen_ty_6 = 6;
pub const kTransArmOff: _bindgen_ty_6 = 7;
pub const kTransMonitorOn: _bindgen_ty_6 = 8;
pub const kTransMonitorOff: _bindgen_ty_6 = 9;
pub const kTransArm: _bindgen_ty_6 = 10;
pub const kTransMonitor: _bindgen_ty_6 = 11;
pub type _bindgen_ty_6 = u32;
pub type ASIOIoFormatType = ::std::os::raw::c_long;
pub const ASIOIoFormatType_e_kASIOFormatInvalid: ASIOIoFormatType_e = -1;
pub const ASIOIoFormatType_e_kASIOPCMFormat: ASIOIoFormatType_e = 0;
pub const ASIOIoFormatType_e_kASIODSDFormat: ASIOIoFormatType_e = 1;
pub type ASIOIoFormatType_e = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIOIoFormat_s {
    pub FormatType: ASIOIoFormatType,
    pub future: [::std::os::raw::c_char; 504usize],
}
#[test]
fn bindgen_test_layout_ASIOIoFormat_s() {
    assert_eq!(
        ::std::mem::size_of::<ASIOIoFormat_s>(),
        512usize,
        concat!("Size of: ", stringify!(ASIOIoFormat_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOIoFormat_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOIoFormat_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOIoFormat_s>())).FormatType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOIoFormat_s),
            "::",
            stringify!(FormatType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASIOIoFormat_s>())).future as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOIoFormat_s),
            "::",
            stringify!(future)
        )
    );
}
pub type ASIOIoFormat = ASIOIoFormat_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIOInternalBufferInfo {
    pub inputSamples: ::std::os::raw::c_long,
    pub outputSamples: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ASIOInternalBufferInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASIOInternalBufferInfo>(),
        16usize,
        concat!("Size of: ", stringify!(ASIOInternalBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASIOInternalBufferInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASIOInternalBufferInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOInternalBufferInfo>())).inputSamples as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInternalBufferInfo),
            "::",
            stringify!(inputSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASIOInternalBufferInfo>())).outputSamples as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASIOInternalBufferInfo),
            "::",
            stringify!(outputSamples)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z15ASIOOutputReadyv"]
    pub fn ASIOOutputReady() -> ASIOError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CodeFragment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct CodeFragments {
    pub root: *mut CodeFragment,
    pub numFragments: ::std::os::raw::c_long,
    pub gARefNum: ::std::os::raw::c_short,
    pub defVol: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_CodeFragments() {
    assert_eq!(
        ::std::mem::size_of::<CodeFragments>(),
        24usize,
        concat!("Size of: ", stringify!(CodeFragments))
    );
    assert_eq!(
        ::std::mem::align_of::<CodeFragments>(),
        8usize,
        concat!("Alignment of ", stringify!(CodeFragments))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CodeFragments>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CodeFragments),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CodeFragments>())).numFragments as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CodeFragments),
            "::",
            stringify!(numFragments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CodeFragments>())).gARefNum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CodeFragments),
            "::",
            stringify!(gARefNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CodeFragments>())).defVol as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(CodeFragments),
            "::",
            stringify!(defVol)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments11newInstanceElPm"]
    pub fn CodeFragments_newInstance(
        this: *mut CodeFragments,
        index: ::std::os::raw::c_long,
        cID: *mut ::std::os::raw::c_ulong,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments14removeInstanceElm"]
    pub fn CodeFragments_removeInstance(
        this: *mut CodeFragments,
        index: ::std::os::raw::c_long,
        cID: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments7getNameElPc"]
    pub fn CodeFragments_getName(
        this: *mut CodeFragments,
        index: ::std::os::raw::c_long,
        name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments13loadFragmentsEsll"]
    pub fn CodeFragments_loadFragments(
        this: *mut CodeFragments,
        folderRef: ::std::os::raw::c_short,
        fileType: ::std::os::raw::c_long,
        resType: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments9setFolderEPc"]
    pub fn CodeFragments_setFolder(
        this: *mut CodeFragments,
        folderName: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments18openFragmentFolderEPvPcPs"]
    pub fn CodeFragments_openFragmentFolder(
        this: *mut CodeFragments,
        specs: *mut ::std::os::raw::c_void,
        foldername: *mut ::std::os::raw::c_char,
        found_vref: *mut ::std::os::raw::c_short,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments24getFrontProcessDirectoryEPv"]
    pub fn CodeFragments_getFrontProcessDirectory(
        this: *mut CodeFragments,
        specs: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragments9getDefVolEv"]
    pub fn CodeFragments_getDefVol(this: *mut CodeFragments) -> ::std::os::raw::c_short;
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragmentsC1EPcll"]
    pub fn CodeFragments_CodeFragments(
        this: *mut CodeFragments,
        folderName: *mut ::std::os::raw::c_char,
        fileType: ::std::os::raw::c_long,
        resType: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13CodeFragmentsD1Ev"]
    pub fn CodeFragments_CodeFragments_destructor(this: *mut CodeFragments);
}
impl CodeFragments {
    #[inline]
    pub unsafe fn newInstance(
        &mut self,
        index: ::std::os::raw::c_long,
        cID: *mut ::std::os::raw::c_ulong,
    ) -> bool {
        CodeFragments_newInstance(self, index, cID)
    }
    #[inline]
    pub unsafe fn removeInstance(
        &mut self,
        index: ::std::os::raw::c_long,
        cID: ::std::os::raw::c_ulong,
    ) {
        CodeFragments_removeInstance(self, index, cID)
    }
    #[inline]
    pub unsafe fn getName(
        &mut self,
        index: ::std::os::raw::c_long,
        name: *mut ::std::os::raw::c_char,
    ) -> bool {
        CodeFragments_getName(self, index, name)
    }
    #[inline]
    pub unsafe fn loadFragments(
        &mut self,
        folderRef: ::std::os::raw::c_short,
        fileType: ::std::os::raw::c_long,
        resType: ::std::os::raw::c_long,
    ) {
        CodeFragments_loadFragments(self, folderRef, fileType, resType)
    }
    #[inline]
    pub unsafe fn setFolder(&mut self, folderName: *mut ::std::os::raw::c_char) -> bool {
        CodeFragments_setFolder(self, folderName)
    }
    #[inline]
    pub unsafe fn openFragmentFolder(
        &mut self,
        specs: *mut ::std::os::raw::c_void,
        foldername: *mut ::std::os::raw::c_char,
        found_vref: *mut ::std::os::raw::c_short,
    ) -> bool {
        CodeFragments_openFragmentFolder(self, specs, foldername, found_vref)
    }
    #[inline]
    pub unsafe fn getFrontProcessDirectory(&mut self, specs: *mut ::std::os::raw::c_void) -> bool {
        CodeFragments_getFrontProcessDirectory(self, specs)
    }
    #[inline]
    pub unsafe fn getDefVol(&mut self) -> ::std::os::raw::c_short {
        CodeFragments_getDefVol(self)
    }
    #[inline]
    pub unsafe fn new(
        folderName: *mut ::std::os::raw::c_char,
        fileType: ::std::os::raw::c_long,
        resType: ::std::os::raw::c_long,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        CodeFragments_CodeFragments(&mut __bindgen_tmp, folderName, fileType, resType);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        CodeFragments_CodeFragments_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct AsioDrivers {
    pub _base: CodeFragments,
    pub connID: ::std::os::raw::c_ulong,
    pub curIndex: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_AsioDrivers() {
    assert_eq!(
        ::std::mem::size_of::<AsioDrivers>(),
        40usize,
        concat!("Size of: ", stringify!(AsioDrivers))
    );
    assert_eq!(
        ::std::mem::align_of::<AsioDrivers>(),
        8usize,
        concat!("Alignment of ", stringify!(AsioDrivers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioDrivers>())).connID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioDrivers),
            "::",
            stringify!(connID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AsioDrivers>())).curIndex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AsioDrivers),
            "::",
            stringify!(curIndex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11AsioDrivers20getCurrentDriverNameEPc"]
    pub fn AsioDrivers_getCurrentDriverName(
        this: *mut AsioDrivers,
        name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN11AsioDrivers14getDriverNamesEPPcl"]
    pub fn AsioDrivers_getDriverNames(
        this: *mut AsioDrivers,
        names: *mut *mut ::std::os::raw::c_char,
        maxDrivers: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__ZN11AsioDrivers10loadDriverEPc"]
    pub fn AsioDrivers_loadDriver(
        this: *mut AsioDrivers,
        name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN11AsioDrivers19removeCurrentDriverEv"]
    pub fn AsioDrivers_removeCurrentDriver(this: *mut AsioDrivers);
}
extern "C" {
    #[link_name = "\u{1}__ZN11AsioDriversC1Ev"]
    pub fn AsioDrivers_AsioDrivers(this: *mut AsioDrivers);
}
extern "C" {
    #[link_name = "\u{1}__ZN11AsioDriversD1Ev"]
    pub fn AsioDrivers_AsioDrivers_destructor(this: *mut AsioDrivers);
}
impl AsioDrivers {
    #[inline]
    pub unsafe fn getCurrentDriverName(&mut self, name: *mut ::std::os::raw::c_char) -> bool {
        AsioDrivers_getCurrentDriverName(self, name)
    }
    #[inline]
    pub unsafe fn getDriverNames(
        &mut self,
        names: *mut *mut ::std::os::raw::c_char,
        maxDrivers: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        AsioDrivers_getDriverNames(self, names, maxDrivers)
    }
    #[inline]
    pub unsafe fn loadDriver(&mut self, name: *mut ::std::os::raw::c_char) -> bool {
        AsioDrivers_loadDriver(self, name)
    }
    #[inline]
    pub unsafe fn removeCurrentDriver(&mut self) {
        AsioDrivers_removeCurrentDriver(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        AsioDrivers_AsioDrivers(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        AsioDrivers_AsioDrivers_destructor(self)
    }
}
